// bulkIndex.test.ts
import { describe, expect, it } from 'vitest'
import {
  type IdFunction,
  bulkCreate,
  bulkDelete,
  bulkIndex,
  bulkUpdate,
} from './helpers'
import type { IndexDefinition } from './types/common'
import type { DocumentFor } from './types/documents'

// A dummy index definition for testing purposes
const personIndex = {
  index: 'person',
  body: {
    mappings: {
      properties: {
        name: { type: 'keyword' },
        age: { type: 'integer' },
      },
    },
  },
} as const satisfies IndexDefinition

type PersonIndex = typeof personIndex
type PersonDocument = DocumentFor<PersonIndex>

describe('bulkIndex helper', () => {
  it('builds a bulk insert payload without an id generator', () => {
    const docs: PersonDocument[] = [
      { name: 'John Wick', age: 52 },
      { name: 'Jane Doe', age: 30 },
    ]

    // Call the helper without providing an id function.
    const bulkPayload = bulkIndex<typeof personIndex>(personIndex.index, docs)

    // Expect the index property to match
    expect(bulkPayload.index).toBe('person')
    // Expect the body to have 2 * docs.length entries (an action and a payload for each doc)
    expect(bulkPayload.body.length).toBe(docs.length * 2)

    // For each document, the action object should be { index: {} } and the document should follow
    for (let i = 0; i < docs.length; i++) {
      const action = bulkPayload.body[i * 2]
      const payload = bulkPayload.body[i * 2 + 1]
      expect(action).toEqual({ index: {} })
      expect(payload).toEqual(docs[i])
    }
  })

  it('builds a bulk insert payload with an id generator', () => {
    const docs: PersonDocument[] = [
      { name: 'John Wick', age: 52 },
      { name: 'Jane Doe', age: 30 },
    ]

    // Example id generator: use a slug version of the name.
    const idFn: IdFunction<PersonIndex> = (doc: PersonDocument) =>
      doc.name.toLowerCase().replace(/\s+/g, '-')

    // Call the helper providing the id function.
    const bulkPayload = bulkIndex<typeof personIndex>(
      personIndex.index,
      docs,
      idFn
    )

    expect(bulkPayload.index).toBe('person')
    expect(bulkPayload.body.length).toBe(docs.length * 2)

    for (let i = 0; i < docs.length; i++) {
      const action = bulkPayload.body[i * 2]
      const payload = bulkPayload.body[i * 2 + 1]
      // The action object should now have an _id property generated by idFn.
      expect(action).toEqual({ index: { _id: idFn(docs[i]) } })
      expect(payload).toEqual(docs[i])
    }
  })
})

describe('bulkCreate helper', () => {
  it('builds a bulk create payload correctly', () => {
    const docs: PersonDocument[] = [
      { name: 'Alice', age: 30 },
      { name: 'Bob', age: 35 },
    ]

    // Provide an id generator function that creates an _id from the name.
    const idFn: IdFunction<PersonIndex> = (doc: PersonDocument) =>
      doc.name.toLowerCase()
    const bulkPayload = bulkCreate(personIndex.index, docs, idFn)

    expect(bulkPayload.index).toBe('person')
    // For each document, we expect 2 array elements (action and document).
    expect(bulkPayload.body.length).toBe(docs.length * 2)

    for (let i = 0; i < docs.length; i++) {
      const action = bulkPayload.body[i * 2]
      const payload = bulkPayload.body[i * 2 + 1]
      expect(action).toEqual({ create: { _id: idFn(docs[i]) } })
      expect(payload).toEqual(docs[i])
    }
  })
})

describe('bulkUpdate helper', () => {
  it('builds a correct bulk update payload when using update actions with a doc property', () => {
    // Assume personIndex is defined in your test environment.
    // For this test, DocumentFor<typeof personIndex> is assumed to have at least a "name" and "age" property.
    // Here, we define an update action that updates only the "age" field.
    const updates = [{ doc: { age: 50 } }]

    // Define an ID generator function. For testing, we simply return a fixed value.
    const idFn = (doc: DocumentFor<typeof personIndex>) => 'foo'

    // Call bulkUpdate with the update action(s).
    const bulkPayload = bulkUpdate(personIndex.index, updates, idFn)

    // Since each update action produces 2 array elements (action + payload),
    // we expect the bulk payload body to have length 2.
    expect(bulkPayload.index).toBe('person')
    expect(bulkPayload.body.length).toBe(2)

    // The first element should be the update action metadata.
    const action = bulkPayload.body[0]
    // The second element should be the update payload.
    const payload = bulkPayload.body[1]

    expect(action).toEqual({ update: { _id: 'foo' } })
    expect(payload).toEqual(updates[0])
  })
})

describe('bulkDelete helper', () => {
  it('builds a correct bulk delete payload', () => {
    // For this test, assume we want to delete documents with IDs 'foo' and 'bar'.
    const ids = ['foo', 'bar']

    const bulkPayload = bulkDelete(personIndex.index, ids)

    expect(bulkPayload.index).toBe('person')
    // Each id maps to one delete action, so the length should match the number of ids.
    expect(bulkPayload.body.length).toBe(ids.length)

    // Verify that each element in the body is a delete action with the corresponding _id.
    bulkPayload.body.forEach((item, idx) => {
      expect(item).toEqual({ delete: { _id: ids[idx] } })
    })
  })
})
