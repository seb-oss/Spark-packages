import type { BrunoEnvironment } from '@usebruno/lang'
import { fileToImportName, jsonSerialize, jsonSerializeEnvironment } from '../serialize'
import type { EmittedFile, FlattenedRequest } from '../types'
import { generateRequest } from './generate-request'

/** Options that affect the generated k6 files. */
export interface GenerateMainOptions {
  /** Optional k6 options object -> exported as `export const options = ...` */
  k6Options?: unknown
  /** Optional environment */
  env?: BrunoEnvironment
}

/** Single-file main that inlines all requests in `items` (in order). */
export function generateMain(
  items: FlattenedRequest[],
  opts: GenerateMainOptions = {}
): string {
  const requests = items.flatMap((it, ix) => generateRequest(it.child, ix + 1))
  const env = jsonSerializeEnvironment(opts.env || {})
  const optionsBlock =
    opts.k6Options && typeof opts.k6Options === 'object'
      ? `export const options = ${jsonSerialize(opts.k6Options, true)}\n`
      : ''

  return `// generated by @sebspark/bruno-to-k6
import http from 'k6/http'
import { sleep, check } from 'k6'
import { usingBruno } from '@sebspark/bruno-to-k6/runtime'

${optionsBlock}
const ENV = ${env}
const VARS = {}

export default function () {
  const { bru, req, parse } = usingBruno({ env: ENV, vars: VARS })

${requests.join('\n')}
  sleep(1)
}
`
}

/**
 * Separate-files mode:
 * - returns a `main` that imports each request file and calls run({ ENV, VARS })
 * - plus one emitted file per request under `requests/<path>.js`
 */
export function generateSeparate(
  items: FlattenedRequest[],
  opts: GenerateMainOptions = {}
): { main: string; files: EmittedFile[] } {
  const imports: string[] = []
  const calls: string[] = []
  const taken = new Set<string>()

  for (let i = 0; i < items.length; i++) {
    const it = items[i]
    const stem = lastSegment(it.path) || `req${i + 1}`
    const baseIdent = fileToImportName(stem)
    const local = uniqueImportName(baseIdent, taken)

    imports.push(`import { run as ${local} } from './requests/${it.path}.js'`)
    calls.push(`${local}({ ENV, VARS })`)
  }

  const env = jsonSerializeEnvironment(opts.env || {})
  const optionsBlock =
    opts.k6Options && typeof opts.k6Options === 'object'
      ? `\nexport const options = ${jsonSerialize(opts.k6Options, true)}\n`
      : ''

  const main = `// generated by @sebspark/bruno-to-k6
import { sleep } from 'k6'
${imports.join('\n')}
${optionsBlock}
const ENV = ${env}
const VARS = {}

export default function () {
  ${calls.join('\n  ')}
  sleep(1)
}
`

  const files: EmittedFile[] = items.map((it) => {
    const body = generateRequest(it.child)
      .slice(0, -1) // trim trailing blank line
      .join('\n')

    const contents = `// generated by @sebspark/bruno-to-k6
import http from 'k6/http'
import { check } from 'k6'
import { usingBruno } from '@sebspark/bruno-to-k6/runtime'

export function run({ ENV, VARS } = {}) {
  const { bru, req, parse } = usingBruno({ env: ENV, vars: VARS })

${body}
}
`

    return { filename: `requests/${it.path}.js`, contents }
  })

  return { main, files }
}

/** return last path segment after '/' */
const lastSegment = (p: string) => {
  const idx = p.lastIndexOf('/')
  return idx >= 0 ? p.slice(idx + 1) : p
}

/** ensure import identifier uniqueness in a given file */
const uniqueImportName = (base: string, taken: Set<string>) => {
  let name = base || 'req'
  let n = 1
  while (taken.has(name)) {
    n++
    name = `${base}${n}`
  }
  taken.add(name)
  return name
}
